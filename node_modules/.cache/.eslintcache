[{"/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/index.js":"1","/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/App.js":"2","/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/components/Scatterplot.js":"3","/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/components/Mainplot.js":"4"},{"size":410,"mtime":1679575225000,"results":"5","hashOfConfig":"6"},{"size":1561,"mtime":1679577545389,"results":"7","hashOfConfig":"6"},{"size":1450,"mtime":1679766622769,"results":"8","hashOfConfig":"6"},{"size":6065,"mtime":1679768298376,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"1mzkiln",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"17","messages":"18","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19"},"/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/index.js",[],["20","21"],"/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/App.js",[],"/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/components/Scatterplot.js",[],"/Users/yanguangjing/Downloads/snu-infovis-assn-1-skeleton-master 2/src/components/Mainplot.js",["22","23","24","25","26"],"import React, { useRef, useEffect} from \"react\";\nimport * as d3 from \"d3\";\n\n\n\nconst Mainplot = (props) => {\n\n\tconst splotSvg = useRef(null);\n  const barplotSvg = useRef(null);\n  const svgSize = props.margin * 2 + props.size;\n\t// data mean & deviation\n\tconst dataMean = [d3.mean(props.data.map(d => parseFloat(d[0]))),d3.mean(props.data.map(d => parseFloat(d[1])))];\n\tconst dataDev = [d3.deviation(props.data.map(d => parseFloat(d[0]))),d3.deviation(props.data.map(d => parseFloat(d[1])))];\n\t//barColor\n\tconst barColor = [\"#fff1ac\",\"#d5a4cf\"];\n\n\tlet barSvg, ySvg, lineSvg;\n\n\t//dino plot\n\tuseEffect(() => {\n\t\t//dataset\n\t\tlet datasetX = props.data.map(d => parseFloat(d[0]));\n\t\tlet datasetY = props.data.map(d => parseFloat(d[1]));\n\n\t\t//define axisX\n\t\tlet linearX = d3.scaleLinear().domain([d3.min(datasetX), d3.max(datasetX)]).range([0, props.size]);\n\t\tlet axisX = d3.axisBottom(linearX);\n\n\t\t//define axisY\n\t\tlet linearY = d3.scaleLinear().domain([d3.min(datasetY), d3.max(datasetY)]).range([props.size, 0]);\n\t\tlet axisY = d3.axisLeft(linearY);\n\n\t\t//append axisX\n\t\tconst svg = d3.select(splotSvg.current);\n\t\tsvg.append(\"g\")\n\t \t\t .attr(\"transform\", `translate(${props.margin},${props.size + props.margin})`)\n\t\t\t .call(axisX)\n\n\t\t//append axisY\n\t\tsvg.append(\"g\")\n\t\t\t .attr(\"transform\", `translate(${props.margin},${props.margin})`)\n\t\t\t .call(axisY)\n\n\t\t//append dot\n\t\tconst dotSvg = svg.append(\"g\")\n\t\t\t\t\t\t\t\t\t\t\t.attr(\"transform\", `translate(${props.margin},${props.margin})`)\n\t\tdotSvg.selectAll(\"circle\")\n\t\t\t\t\t.data(props.data)\n\t\t\t\t\t.enter()\n\t\t\t\t\t.append(\"circle\")\n\t\t\t\t\t.attr(\"class\", (_,i) => `circle${i}`)\n\t\t\t\t\t.attr(\"r\", props.radius)\n\t\t\t\t\t.attr(\"cx\", d => linearX(d[0]))\n\t\t\t\t\t.attr(\"cy\", d => linearY(d[1]))\n\n\n\t\t//append brush\n\t\tconst brush = d3.brush()\n      .extent([[0, 0], [props.size, props.size]])\n      .on(\"start brush end\", brushed)\n\t\t\t//.on(\"start\", cleared);\n\t\tconst brushSvg = svg.append(\"g\")\n\t\t\t\t\t\t\t\t\t\t\t\t.attr(\"transform\", `translate(${props.margin},${props.margin})`)\n\t\t\t\t\t\t\t\t\t\t\t\t.call(brush)\n\n\t\t// function cleared(){\n\t\t// \td3.selectAll(\"circle\").attr(\"fill\",\"black\");\n\t\t// }\n\n\t\tfunction brushed(event) {\n    let selection = event.selection;\n\t\t\n\t\t// brush none dot\n    if (selection == null) {\n      d3.selectAll(\"circle\").attr(\"fill\", \"black\");\n\t\t\tbarUpdate(dataMean,dataDev);\n      return;\n    }\n\t\tlet [[x0, y0],[x1, y1]] = selection;\n\t\t//in section\n\t\tconst databrushed = props.data.map((d, i)=>{\n\t\t\tconst dataTX = linearX(parseFloat(d[0]));\n\t\t\tconst dataTY = linearY(parseFloat(d[1]));\n\t\t\tif(x0 <= dataTX && dataTX <= x1 && y0 <= dataTY && dataTY <= y1\n\t\t\t\t)return true;\n\t\t\telse return false;\t\n\t\t});\n\t\tconst inSectionId = databrushed.reduce((acc, cur, i) => {\n\t\t\tif (cur) acc.push(i);\n\t\t\treturn acc;\n\t\t}, [])\n\t\td3.selectAll(\"circle\").attr(\"fill\",\"black\");\n\t\t// set section color\n\t\tinSectionId.forEach(e =>{\n\t\t\td3.selectAll(`.circle${e}`)\n\t\t\t\t.attr(\"fill\",\"red\");\n\t\t} )\n\t\t// brush update\n\t\tif( inSectionId.length === 0 || inSectionId.length === 1){\n\t\t\tbarUpdate(dataMean,dataDev);\n\t\t}else\n\t\t{\n\t\t\tconst sectionDataMean = [d3.mean(inSectionId.map(id => parseFloat(props.data[id][0]))),d3.mean(inSectionId.map(id => parseFloat(props.data[id][1])))];\n\t\t\tconst sectionDataDev = [d3.deviation(inSectionId.map(i => parseFloat(props.data[i][0]))),d3.deviation(inSectionId.map(i => parseFloat(props.data[i][1])))];\n\t\t\tbarUpdate(sectionDataMean,sectionDataDev);\n\t\t}\n  }\n\t// eslint-disable-next-line\n\t}, []);\n\n\t//bar plot\n\tuseEffect(()=>{\n\t\t//define axisX\n\t\tconst xScale  = d3.scaleBand().domain([0, 1]).range([0, props.size]).align(0.5).padding(props.barPadding);\n\t\tconst tickText  = d3.scaleBand().domain([\"x\", \"y\"]).range([0, props.size]).align(0.5).padding(props.barPadding);\n\t\tlet axisX = d3.axisBottom(tickText);\n\n\t\t//define axisY\n\t\tconst yMax = d3.max([dataMean[0],dataMean[1]]);\n\t\tconst yScale  = d3.scaleLinear().domain([0, yMax]).range([props.size, 0]);\n\t\tlet axisY = d3.axisLeft(yScale);\n\n\t\t//append axisX\n\t\tconst svg = d3.select(barplotSvg.current);\n\t\tconst xSvg = svg.append(\"g\")\n\t \t\t .attr(\"transform\", `translate(${props.margin},${props.size + props.margin})`)\n\t\t\t .call(axisX)\n\n\t\t//append axisY\n\t\tySvg = svg.append(\"g\")\n\t\t\t .attr(\"transform\", `translate(${props.margin},${props.margin})`)\n\t\t\t .call(axisY)\n\n\t\t//append bar\n\t\tbarSvg = svg.append(\"g\")\n\t\t\t\t\t\t\t\t.attr(\"transform\", `translate(${props.margin},${props.margin})`);\n\n\t\tbarSvg.selectAll(\"rect\")\n\t\t\t\t\t.data(dataMean)\n\t\t\t\t\t.enter()\n\t\t\t\t\t.append(\"rect\")\n\t\t\t\t\t.attr(\"width\", xScale.bandwidth())\n          .attr(\"height\", d => props.size - yScale(d))\n\t\t\t\t\t.attr(\"x\", (_,i) => xScale(i))\n\t\t\t\t\t.attr(\"y\",(d,_) => yScale(d))\n\t\t\t\t\t.attr(\"fill\",(_,i)=>barColor[i])\n\n\t\t//append errorbar\n\t\tlineSvg = svg.append(\"g\")\n\t\t\t\t\t\t\t\t .attr(\"transform\", `translate(${props.margin},${props.margin})`);\n\t\t\n\t\tlineSvg.selectAll(\"line\")\n\t\t\t\t\t .data(dataDev)\n\t\t\t\t\t .enter()\n\t\t\t\t\t .append(\"line\")\n\t\t\t\t\t .style(\"stroke\",\"black\")\n\t\t\t\t\t .attr(\"x1\", (d, i) => xScale(i) + xScale.bandwidth() / 2)\n           .attr(\"x2\", (d, i) => xScale(i) + xScale.bandwidth() / 2)\n           .attr(\"y1\", (d, i) => yScale(dataMean[i] + d))\n           .attr(\"y2\", (d, i) => yScale(dataMean[i] - d))\n\n\t},[])\n\n\t// update barplot\n\tfunction barUpdate(updateMean, updateDev){\n\t\t//define axisY\n\t\tconst yMax = d3.max(updateMean);\n\t\tconst yScale = d3.scaleLinear().domain([0, yMax]).range([props.size, 0]);\n\t\tlet axisY = d3.axisLeft(yScale);\n\t\n\t\t//append axisY\n\t\tySvg.call(axisY)\n\t\t\n\t\tbarSvg.selectAll(\"rect\")\n\t\t\t\t\t.data(updateMean)\n\t\t\t\t\t.join()\n\t\t\t\t\t.transition()\n\t\t\t\t\t.duration(10)\n\t\t\t\t\t.attr(\"y\",d => yScale(d))\n\t\t\t\t\t.attr(\"height\",d => {\n\t\t\t\t\t\treturn props.size - yScale(d);});\n\n\t\tlineSvg.selectAll(\"line\")\n\t\t\t\t\t .data(updateDev)\n\t\t\t\t\t .join()\n\t\t\t\t\t .transition()\n\t\t\t\t\t .duration(60)\n\t\t\t\t\t .style(\"stroke\",\"black\")\n           .attr(\"y1\", (d, i) => yScale(updateMean[i] + d))\n           .attr(\"y2\", (d, i) => yScale(updateMean[i] - d))\n\t\t\t\n\t\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<svg ref={splotSvg} width={svgSize} height={svgSize}> \n\t\t\t</svg>\n      <svg ref={barplotSvg} width={svgSize} height={svgSize}> \n\t\t\t</svg>\n\n\t\t</div>\n\t)\n};\n\nexport default Mainplot;",{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":62,"column":9,"nodeType":"33","messageId":"34","endLine":62,"endColumn":17},{"ruleId":"31","severity":1,"message":"35","line":125,"column":9,"nodeType":"33","messageId":"34","endLine":125,"endColumn":13},{"ruleId":"36","severity":1,"message":"37","line":130,"column":10,"nodeType":"38","endLine":132,"endColumn":17},{"ruleId":"36","severity":1,"message":"39","line":135,"column":12,"nodeType":"38","endLine":136,"endColumn":73},{"ruleId":"36","severity":1,"message":"40","line":149,"column":13,"nodeType":"38","endLine":150,"endColumn":74},"no-native-reassign",["41"],"no-negated-in-lhs",["42"],"no-unused-vars","'brushSvg' is assigned a value but never used.","Identifier","unusedVar","'xSvg' is assigned a value but never used.","react-hooks/exhaustive-deps","Assignments to the 'ySvg' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","CallExpression","Assignments to the 'barSvg' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","Assignments to the 'lineSvg' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","no-global-assign","no-unsafe-negation"]